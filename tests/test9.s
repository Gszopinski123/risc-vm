#
# RISC-V 32-bit Assembly Test Program for Emulator
# This program demonstrates a variety of RV32I and RV32C instructions
# to test the functionality of a RISC-V emulator.
#
# To compile:
# riscv64-unknown-elf-gcc -march=rv32ic -mabi=ilp32 -O0 -nostdlib -nostartfiles -Ttext=0x0C000000 -o test_riscv_emulator.elf test_riscv_emulator.S
#
# To run with your emulator:
# ./your_emulator test_riscv_emulator.elf
#

.option norvc     # Ensure compressed instructions are explicitly generated by the assembler
                  # when using specific directives or simple operations that map to them.
                  # For this test, we want to see both expanded and compressed forms.
                  # Remove this line if you want the assembler to prefer compressed for everything.

.global _start
.section .text    # Code section
.org 0x0C000000   # Start address matching your emulator's PC_START

_start:
    # Initialize registers for testing
    # Using typical ABI names where possible:
    # x0: zero, x1: ra (return address), x2: sp (stack pointer)
    # x5-x7: t0-t2 (temporaries), x8-x9: s0-s1 (saved registers)
    # x10-x11: a0-a1 (arguments/return values)

    # Set stack pointer (x2/sp) to a reasonable memory location
    # Using 'li' pseudo-instruction for full 32-bit immediate
    li      sp, 0x1FFFFFFC          # sp = 0x1FFFFFFC # pass
                                    # Fix: Was 'lui sp, 0x1FFFF' then 'addi sp, sp, 0xFFC' (0xFFC out of range)

    # Basic setup for some general-purpose registers
    addi    t0, x0, 10              # t0 (x5) = 10 (immediate 10 is in range) #pass
    addi    t1, x0, 5               # t1 (x6) = 5 (immediate 5 is in range) #pass
    addi    t2, x0, -3              # t2 (x7) = -3 (immediate -3 is in range) #pass
    li      a0, 0x1234              # a0 (x10) = 0x1234 #pass
                                    # Fix: Was 'addi a0,x0,0x1234' (0x1234 out of range)
    li      a1, 0xABCD              # a1 (x11) = 0xABCD #pass
                                    # Fix: Was 'addi a1,x0,0xABCD' (0xABCD out of range)

    # ----------------------------------------
    # R-Type Instructions (Register-Register)
    # Format: opcode rd, rs1, rs2 (funct3, funct7)
    # ----------------------------------------

    # ADD
    add     s0, t0, t1              # s0 (x8) = t0 + t1 = 10 + 5 = 15 #pass
    # SUB
    sub     s1, t0, t1              # s1 (x9) = t0 - t1 = 10 - 5 = 5 #pass
    # XOR
    xor     t0, t0, t1              # t0 (x5) = 10 ^ 5 = 15 (0xA ^ 0x5 = 0xF) #pass
    # OR
    or      t1, t0, t1              # t1 (x6) = t0 | t1 (new t0 is 15, t1 is 5) = 15 | 5 = 15 #pass
    # AND
    and     t2, t0, t1              # t2 (x7) = t0 & t1 (new t0 is 15, t1 is 15) = 15 & 15 = 15 #pass
    
    # SLL (Shift Left Logical)
    sll     a0, t0, t1              # a0 (x10) = t0 << t1 (15 << 15) #pass
    # SRL (Shift Right Logical)
    srl     a1, a0, t1              # a1 (x11) = a0 >> t1 (unsigned shift) #pass
    # SRA (Shift Right Arithmetic)
    sra     s0, t2, t1              # s0 (x8) = t2 >> t1 (-3 >> 5, signed shift) not what it says it is but #pass

    # SLT (Set Less Than)
    slt     s1, t1, t0              # s1 (x9) = (t1 < t0) ? 1 : 0 (15 < 15 is false, so 0) #pass
    # SLTU (Set Less Than Unsigned)
    sltu    t0, t1, t0              # t0 (x5) = (t1 < t0) ? 1 : 0 (unsigned comparison, 15 < 15 is false, so 0) #pass


    # ----------------------------------------
    # I-Type Instructions (Immediate-Register)
    # Format: opcode rd, rs1, imm (funct3)
    # ----------------------------------------

    # ADDI
    addi    t0, x0, 20              # t0 (x5) = 20
    addi    t1, t0, 5               # t1 (x6) = t0 + 5 = 25
    # XORI
    xori    t2, t0, 0xAA            # t2 (x7) = t0 ^ 0xAA = 20 ^ 0xAA
    # ORI
    ori     a0, t1, 0x55            # a0 (x10) = t1 | 0x55 = 25 | 0x55
    # ANDI
    andi    a1, t2, 0xF0            # a1 (x11) = t2 & 0xF0

    # SLLI
    slli    s0, t0, 3               # s0 (x8) = t0 << 3 (20 << 3 = 160)
    # SRLI
    srli    s1, s0, 2               # s1 (x9) = s0 >> 2 (unsigned shift)
    # SRAI
    srai    t2, t2, 1               # t2 (x7) = t2 >> 1 (signed shift)

    # SLTI
    slti    t0, t1, 30              # t0 (x5) = (t1 < 30) ? 1 : 0 (25 < 30 is true, so 1)
    # SLTIU
    sltiu   t1, t0, 0xFF            # t1 (x6) = (1 < 0xFF) ? 1 : 0 (1 < 0xFF is true, so 1)


    # ----------------------------------------
    # U-Type Instructions (Upper Immediate)
    # Format: opcode rd, imm
    # ----------------------------------------

    # LUI (Load Upper Immediate)
    lui     a0, 0x12345             # a0 (x10) = 0x12345000 (loads 20-bit imm into upper 20 bits)
    # AUIPC (Add Upper Immediate to PC)
    auipc   a1, 0xABCDE             # a1 (x11) = PC + (0xABCDE << 12) (current PC + 0xABCDE000)


    # ----------------------------------------
    # J-Type Instruction (Jump)
    # Format: opcode rd, imm
    # ----------------------------------------

    # JAL (Jump and Link)
    jal     ra, function_target     # ra (x1) = PC + 4, PC = function_target

    # This code will execute after returning from function_target
    addi    s0, s0, 100             # s0 = s0 + 100


    # ----------------------------------------
    # B-Type Instructions (Branch)
    # Format: opcode rs1, rs2, imm (funct3)
    # ----------------------------------------

    addi    t0, x0, 7
    addi    t1, x0, 7

    # BEQ (Branch Equal)
    beq     t0, t1, branch_equal    # If t0 == t1, branch to branch_equal
    addi    s0, s0, 1               # This instruction skipped if branch is taken
branch_equal:
    li      t3, 1000                # Load 1000 into temporary register t3
    add     s0, s0, t3              # s0 = s0 + 1000
                                    # Fix: Was 'addi s0,s0,1000' (1000 is in range, but using li+add here for consistency if future values are large)

    addi    t1, x0, 8
    # BNE (Branch Not Equal)
    bne     t0, t1, branch_not_equal # If t0 != t1, branch to branch_not_equal
    addi    s0, s0, 2               # This instruction skipped if branch is taken
branch_not_equal:
    li      t3, 2000
    add     s0, s0, t3              # s0 = s0 + 2000
                                    # Fix: Was 'addi s0,s0,2000' (2000 is in range, but using li+add for consistency)

    addi    t0, x0, 5
    addi    t1, x0, 10
    # BLT (Branch Less Than)
    blt     t0, t1, branch_less_than # If t0 < t1, branch to branch_less_than
    addi    s0, s0, 3               # This instruction skipped
branch_less_than:
    li      t3, 3000
    add     s0, s0, t3              # s0 = s0 + 3000
                                    # Fix: Was 'addi s0,s0,3000' (3000 out of range)

    addi    t0, x0, 10
    addi    t1, x0, 5
    # BGE (Branch Greater Than or Equal)
    bge     t0, t1, branch_greater_equal # If t0 >= t1, branch to branch_greater_equal
    addi    s0, s0, 4               # This instruction skipped
branch_greater_equal:
    li      t3, 4000
    add     s0, s0, t3              # s0 = s0 + 4000
                                    # Fix: Was 'addi s0,s0,4000' (4000 out of range)

    # BLTU (Branch Less Than Unsigned)
    # Use larger unsigned numbers to show difference from signed BLT
    lui     t0, 0x80000             # t0 = 0x80000000 (signed negative, unsigned large)
    addi    t1, x0, 1               # t1 = 1
    bltu    t1, t0, branch_less_than_unsigned # 1 < 0x80000000 (true unsigned), branch taken
    addi    s0, s0, 5               # Skipped
branch_less_than_unsigned:
    li      t3, 5000
    add     s0, s0, t3              # s0 = s0 + 5000
                                    # Fix: Was 'addi s0,s0,5000' (5000 out of range)

    # BGEU (Branch Greater Than or Equal Unsigned)
    bgeu    t0, t1, branch_greater_equal_unsigned # 0x80000000 >= 1 (true unsigned), branch taken
    addi    s0, s0, 6               # Skipped
branch_greater_equal_unsigned:
    li      t3, 6000
    add     s0, s0, t3              # s0 = s0 + 6000
                                    # Fix: Was 'addi s0,s0,6000' (6000 out of range)


    # ----------------------------------------
    # Load and Store Instructions
    # Format (I-type load): opcode rd, imm(rs1)
    # Format (S-type store): opcode rs2, imm(rs1)
    # ----------------------------------------

    # Load from data section
    # Calculate address of data_word1
    la      t0, data_word1          # t0 (x5) = address of data_word1
    # LW (Load Word)
    lw      s0, 0(t0)               # s0 (x8) = value at data_word1 (0xDEADBEEF)

    # Store to data section
    li      s1, 0x11223344          # s1 (x9) = 0x11223344
                                    # Fix: Was 'addi s1,x0,0x11223344' (0x11223344 out of range)
    # SW (Store Word)
    sw      s1, 4(t0)               # Store s1 to data_word2 (address t0 + 4)

    # LB (Load Byte)
    lb      t1, 0(t0)               # t1 (x6) = least significant byte of data_word1 (0xEF, sign-extended)
    # SB (Store Byte)
    addi    t2, x0, 0xCC            # t2 (x7) = 0xCC (immediate 0xCC is in range)
    sb      t2, 8(t0)               # Store t2 to data_byte1 (address t0 + 8)

    # LH (Load Half-word)
    lh      a0, 0(t0)               # a0 (x10) = least significant half-word of data_word1 (0xBEEF, sign-extended)
    # SH (Store Half-word)
    li      a1, 0xABCD              # a1 (x11) = 0xABCD
                                    # Fix: Was 'addi a1,x0,0xABCD' (0xABCD out of range)
    sh      a1, 10(t0)              # Store a1 to data_halfword1 (address t0 + 10)

    # LBU (Load Byte Unsigned)
    lbu     s0, 9(t0)               # s0 (x8) = value at data_byte2 (0x01, zero-extended)
    # LHU (Load Half-word Unsigned)
    lhu     s1, 12(t0)              # s1 (x9) = value at data_halfword2 (0xFEFF, zero-extended)


    # ----------------------------------------
    # Compressed Instructions (RV32C)
    # These are often generated by the assembler/compiler
    # for simpler operations or specific registers.
    # We use specific register numbers (x8-x15) to encourage C-instruction generation.
    # ----------------------------------------

    # c.addi (Add Immediate to Register)
    # Equivalent to addi rd, rd, imm
    addi    x8, x8, 5               # x8 (s0) = x8 + 5 (likely c.addi)
    addi    x9, x9, 10              # x9 (s1) = x9 + 10 (likely c.addi)
    addi    x10, x10, 15            # x10 (a0) = x10 + 15 (likely c.addi)

    # c.li (Load Immediate) - pseudo-instruction
    # Typically translated to c.addi, or addi x, x0, imm
    li      x12, 123                # x12 (a2) = 123 (likely c.li)
    li      x13, -45                # x13 (a3) = -45 (likely c.li)

    # c.mv (Move Register) - pseudo-instruction
    # Equivalent to addi rd, rs, 0
    mv      x14, x13                # x14 (a4) = x13 (likely c.mv)

    # c.lwsp (Load Word from SP with offset)
    # lw rd, offset(sp)
    # Requires specific alignment and offset for c.lwsp.
    # Let's push some values to stack and then pop using c.lwsp
    li      t0, 0xAAAA              # t0 = 0xAAAA
                                    # Fix: Was 'addi t0,x0,0xAAAA' (0xAAAA out of range)
    li      t1, 0xBBBB              # t1 = 0xBBBB
                                    # Fix: Was 'addi t1,x0,0xBBBB' (0xBBBB out of range)
    sw      t0, 0(sp)               # Store t0 at sp
    sw      t1, -4(sp)              # Store t1 at sp - 4
    lw      x15, -4(sp)             # x15 (a5) = 0xBBBB (likely c.lwsp if offset is small and aligned)

    # c.swsp (Store Word to SP with offset)
    # sw rs, offset(sp)
    li      x15, 0xCCCC             # x15 = 0xCCCC
                                    # Fix: Was 'addi x15,x0,0xCCCC' (0xCCCC out of range)
    sw      x15, 0(sp)              # Store x15 to sp (likely c.swsp)

    # c.lw (Load Word - special case of lw for certain registers and offsets)
    # lw rd', offset(rs1') where rd', rs1' are 8-15 (s0-s7/t3-t6)
    la      x8, data_word3          # x8 (s0) = address of data_word3
    lw      x9, 0(x8)               # x9 (s1) = data_word3 (0xCCFFEE11) (likely c.lw)

    # c.sw (Store Word - special case of sw for certain registers and offsets)
    li      x10, 0xDEAD             # x10 (a0) = 0xDEAD
                                    # Fix: Was 'addi x10,x0,0xDEAD' (0xDEAD out of range)
    sw      x10, 4(x8)              # Store x10 to data_word4 (x8 + 4) (likely c.sw)

    # c.slli (Shift Left Logical Immediate)
    # slli rd, rd, shamt
    slli    x8, x8, 2               # x8 = x8 << 2 (likely c.slli)

    # c.srli (Shift Right Logical Immediate)
    # srli rd', rd', shamt
    srli    x9, x9, 1               # x9 = x9 >> 1 (logical) (likely c.srli)

    # c.srai (Shift Right Arithmetic Immediate)
    # srai rd', rd', shamt
    addi    x10, x0, -100           # x10 = -100 (immediate is in range)
    srai    x10, x10, 2             # x10 = x10 >> 2 (arithmetic) (likely c.srai)

    # c.andi (AND Immediate)
    # andi rd', rd', imm
    andi    x8, x8, 0xFC            # x8 = x8 & 0xFC (likely c.andi)

    # c.add (Add Register)
    # add rd', rs1'
    add     x9, x9, x8              # x9 = x9 + x8 (likely c.add)

    # c.sub (Subtract Register)
    # sub rd', rs1'
    sub     x10, x10, x9            # x10 = x10 - x9 (likely c.sub)

    # c.xor (XOR Register)
    # xor rd', rs1'
    xor     x8, x8, x9              # x8 = x8 ^ x9 (likely c.xor)

    # c.or (OR Register)
    # or rd', rs1'
    or      x9, x9, x10             # x9 = x9 | x10 (likely c.or)

    # c.and (AND Register)
    # and rd', rs1'
    and     x10, x10, x8            # x10 = x10 & x8 (likely c.and)

    # c.j (Jump) - pseudo-instruction for jal x0, offset
    j       jump_target             # PC = jump_target (likely c.j)

    addi    t0, t0, 1               # This instruction is skipped

jump_target:
    addi    t0, t0, 100             # t0 = t0 + 100

    # c.jr (Jump Register) - pseudo-instruction for jalr x0, rs1, 0
    # Use to return from a function if ra is not needed, or as an indirect jump.
    la      t0, return_from_jr      # t0 = address of return_from_jr
    jr      t0                      # PC = t0 (likely c.jr)

    addi    t0, t0, 2               # This is skipped

return_from_jr:
    addi    t0, t0, 200             # t0 = t0 + 200

    # c.jal (Jump and Link) - pseudo-instruction for jal ra, offset
    jal     c_jal_target            # ra = PC+2, PC = c_jal_target (likely c.jal)
    # This code will execute after returning from c_jal_target
    addi    t0, t0, 300             # t0 = t0 + 300

    # c.jalr (Jump and Link Register) - pseudo-instruction for jalr ra, rs1, 0
    la      t0, end_program_marker  # t0 = address of end_program_marker
    jalr    x0, t0, 0               # ra = PC+2, PC = t0 (likely c.jalr). Explicitly use x0 for rd.
    # This code is skipped as we jump directly to the end

c_jal_target:
    addi    t0, t0, 400             # t0 = t0 + 400
    jalr    x0, ra, 0               # Return to caller using ra (common for 'ret' pseudo-instruction).
                                    # Used x0 for rd because we don't care about its return value here.

    # c.beqz (Branch Equal to Zero)
    # beq rs', x0, offset
    addi    x8, x0, 0               # x8 = 0
    beqz    x8, branch_beqz_taken   # If x8 == 0, branch taken (likely c.beqz)
    addi    t0, t0, 5               # Skipped
branch_beqz_taken:
    addi    t0, t0, 500             # t0 = t0 + 500

    # c.bnez (Branch Not Equal to Zero)
    # bne rs', x0, offset
    addi    x9, x0, 1               # x9 = 1
    bnez    x9, branch_bnez_taken   # If x9 != 0, branch taken (likely c.bnez)
    addi    t0, t0, 6               # Skipped
branch_bnez_taken:
    addi    t0, t0, 600             # t0 = t0 + 600

    # c.nop (No Operation) - c.addi x0, x0, 0
    nop                             # A standard NOP. If your emulator handles c.addi x0, x0, 0
                                    # as c.nop, this will test it.

end_program_marker:
    # ----------------------------------------
    # Program Termination
    # ----------------------------------------
    # ECALL (Environment Call)
    # Used for system calls. Your emulator uses this to terminate.
    ecall                           # Triggers a trap, leading to program exit in your emulator.


# ----------------------------------------
# Helper Function for JAL testing
# ----------------------------------------
function_target:
    addi    t0, t0, 50              # t0 = t0 + 50
    addi    t1, t1, 20              # t1 = t1 + 20
    add     s0, t0, t1              # s0 = t0 + t1
    jalr    x0, ra, 0               # Return to caller. Equivalent to 'ret' pseudo-instruction.


.section .data    # Data section
    .align 2      # Ensure data is 4-byte aligned

data_word1:
    .word 0xDEADBEEF  # A 32-bit word
data_word2:
    .word 0xCAFEFEED  # Another 32-bit word, will be overwritten
data_byte1:
    .byte 0xFF        # A byte
data_byte2:
    .byte 0x01        # Another byte, will be overwritten
data_halfword1:
    .half 0x1234      # A 16-bit half-word
data_halfword2:
    .half 0xFEFF      # Another 16-bit half-word

data_word3:
    .word 0xCCFFEE11
data_word4:
    .word 0xAABBCCDD # Will be overwritten by c.sw